# 📂 [Algorithm] 백준 1931 - 회의실 배정

> **관련 링크**: https://www.acmicpc.net/problem/1931
> **난이도**: Gold 5
> **학습 날짜**: 2026-01-21

---

## 1. 문제 해석 🔍
* **목표**: 각 회의가 겹치지 않으면서, 가능한 회의의 최대 개수 찾기
* **입력 값**: 회의의 수 N은 1개에서 10만개 사이, 이후 공백을 두고 시작 시간, 끝나는 시간이 주어짐
* **제약 사항**: 시간 제한 2초, 메모리 제한 128메가
* **핵심 포인트**: 최대 회의 개수를 어떻게 구할 것인가?

## 2. 해결 전략 (아이디어) 💡
* **사용 알고리즘**: 그리디 + 정렬
* **풀이 프로세스**:
    1. 회의의 시작 시간과 끝 시간을 자체 클래스에 담고, List에 넣는다.
    2. List를 끝나는 시간이 빠른 순으로, 같으면 시작 시간이 빠른 순으로 정렬한다.
    3. 반복문을 돈다.
    - currentTime이 시작 시간보다 이전인 회의를 선택한다. ( 그래야 해당 회의가 가능함. )
    - 해당 회의를 진행해야 하므로 currentTime을 해당 회의의 끝나는 시간으로 변경한다.
    - 회의를 하나 고를 때마다 count를 1씩 증가시킨다. ( 가능한 회의 수 세기 ) 
* **핵심 아이디어**
- 매번 끝나는 시간이 가장 빠른 회의를 선택할 때, 최대 회의를 선택할 수 있다.
- 시작 시간이 가장 빠른 회의를 선택해야, 놓치는 회의가 최소가 된다.
- 예) (1,4),(4,4)이면 2개의 회의가 가능하지만 (4,4)(1,4)이면 1개의 회의만 선택 가능하다.
## 3. 복잡도 분석 ⏳
* **시간 복잡도**: O(N logN) : N개의 회의를 끝나는 시간 기준으로 정렬
* **공간 복잡도**: 시작 시간 int, 끝나는 시간 int 2개의 변수를 가진 자체 클래스 10만개

## 4. 핵심 코드 리뷰 ⭐
* **시작 시간 기준도 정렬한다**: 만약 시작 시간이 느린 회의를 해버리면, 이후 시작 시간이 빠른 회의를 진행할 기회를 날려버림

## 5. 트러블슈팅 / 느낀 점 🚩
* **개선 방향**: 그리디라는 걸, 직관에 의존했어서 간단하게라도 증명하면 좋을 것 같다.

## 그리디(Greedy)
- **그리디(Greedy)** : 지금 당장 최선의 선택을 하는 것이, 최종적으로도 최선이다.
- **정당성 증명** : **내가 선택한 최선의 방법이 '다른 어떤 최적해'보다 나쁘지 않음을 보인다.**

1. 가정 : 가장 빨리 끝나는 회의 A를 선택하지 않고, **다른 회의 B를 선택한 '최적의 리스트'가 존재**한다.
2. 증명 : 
 - 가정에 의해, B는 A보단 늦거나 최소한 동시에 끝난다. ( A는 가장 빨리 끝나는 회의 )
 - 정의에 따라 A의 종료 시간 <= B의 종료 시간이다.
 - 이 때, 최적해 리스트에서 B를 빼고 A를 넣어도, A가 B보다는 일찍 혹은 동시에 끝난다.
 - 뒤에 오는 회의들과 겹칠 가능성은 오히려 줄어들거나 같게된다.
 - **결론적으로 회의의 총 개수는 그대로거나 늘어날 수 있지, 줄어들지 않는다.**
3. 결론 : B를 A로 교체해도 결과(회의 개수)가 줄어들지 않기 때문에, 매 순간 가장 빨리 끝나는 회의를 선택하는 것이 최적해를 보장한다.

- **그리디임을 파악하는 직관** 
- 한정된 자원 사용 시, **빨리 비워주는 게 유리**하다. 다음 사람이 들어올 가능성 증대.
- 앞에서 회의 선택 시, 그 선택이 남은 회의의 '선택 가능성'을 방해하지 않는 방향은 **회의가 가장 빨리 끝나는 방향**이다.
# 📂 [Algorithm] 백준 18870 - 좌표 압축

> **관련 링크**: https://www.acmicpc.net/problem/18870
> **난이도**: Silver 2
> **학습 날짜**: 2026-01-21

---

## 1. 문제 해석 🔍
* **목표**: N개의 좌표를 압축한 좌표 압축 결과를 출력하기
* **입력 값**: N개의 좌표 (최대 100만개) ( 각 좌표는 -10억과 10억 사이 )
* **제약 사항**: 시간 제한 2초, 메모리 제한 512MB
* **핵심 포인트**: Xi > Xj일 때 Xj는 서로 다른 좌표여야만 함. ( 같은 좌표는 같이 취급 )

## 2. 해결 전략 (아이디어) 💡
* **사용 알고리즘**: 정렬
* **풀이 프로세스**:
    1. N개의 정수를 리스트에 입력받는다. (이 리스트는 출력 순서를 위해 유지한다. )
    2. 중복 제거를 위해 리스트를 Set에 복사하고, 다시 정렬을 위해 ArrayList에 담고 정렬한다.
    3. 정렬된 이 리스트의 인덱스는 결국 자신보다 작은 수의 개수가 되므로 Map 담는다.
    4. Map에 담을 때 숫자를 Key로 하면 출력 시 O(1)에 Value 검색 후 출력한다. 
* **핵심 아이디어**: 결국 Xi > Xj라는 건 인덱스와 동일시도 가능하다.
- 예를 들어, 0번 인덱스는 xi > xj인 좌표가 하나도 없는 것이고
- k번 인덱스는, xi > xj인 좌표가 k개인 것이다.

## 3. 복잡도 분석 ⏳
* **시간 복잡도**: O(N logN) : N개의 정수를 오름차순 정렬
* **공간 복잡도**: 100만개의 Integer 객체 (NlogN 정렬을 위함)

## 4. 핵심 코드 리뷰 ⭐
* **메모리 할당**: 입력 순서를 유지하기 위해 리스트, 정렬 위한 리스트로 리스트 2번 생성으로 메모리 계산에 주의해야한다.

## 5. 트러블슈팅 / 느낀 점 🚩
* **실수했던 점**: sortedList로 중복 제거 후, 원소가 줄어드는 만큼 인덱스를 줄여야 하는걸 간과했었다.
* **개선 방향**: int[]를 쓰면 메모리적으로는 이점이 있다. (단, O(N^2)의 최악의 경우 정렬을 생각할 땐 주의해야 할듯하다.)
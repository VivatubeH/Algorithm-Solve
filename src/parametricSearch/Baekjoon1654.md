# 📂 [Algo] 백준 1654 - 랜선 자르기

> 날짜: 2026-01-27 | 난이도: Silver 2 | 알고리즘: 이분 탐색(매개변수 탐색)

## 1. 문제 분석 💡
**목표**: K개의 랜선으로 N개를 만들 수 있는 최대 길이 찾기

**핵심 아이디어**:
- 이분 탐색으로 "가능한 최대 길이" 찾기
- 판정 함수: length로 잘랐을 때 N개 이상 만들 수 있는가?

**시간 복잡도**: O(K * log M)
- K: 랜선 개수 (최대 10,000)
- M: 랜선 최대 길이 (최대 2^31-1)
- 이분 탐색 O(log M) * 배열 순회 O(K) = O(K * log M)

## 2. 핵심 로직 ⭐
**이분 탐색 범위 설정 (중요!)**:
- left = 1 (0이면 나눗셈 오류)
- right = maxLength (기존 랜선 최대 길이) → ⚠️ 함정: right를 2^31-1로 설정하면 안 됨!

**판정 함수**:
```java
길이 len으로 자를 때 개수 = Σ(array[i] / len)
if (개수 >= N) → 가능
```

**이분 탐색**:
- 가능하면 → answer 갱신 + 더 큰 값 시도 (left = mid + 1)
- 불가능하면 → 더 작은 값 시도 (right = mid - 1)

## 3. 트러블슈팅 & 배운 점 🚩
**함정 1**: 이분 탐색 범위
- ❌ right = Integer.MAX_VALUE → 시간 초과 & 논리 오류
- ✅ right = maxLength (기존 랜선 이상 불가능)

**함정 2**: mid 계산 오버플로우
- ❌ mid = (left + right) / 2 → long 범위 초과 가능
- ✅ mid = left + (right - left) / 2

**최적화**: count >= N이면 즉시 return (불필요한 계산 방지)

## 4. 면접 대비 🎤
Q. "이분 탐색과 매개변수 탐색의 차이는?"
- A. 이분 탐색은 정렬된 배열에서 값 찾기, 매개변수 탐색은 "최적값" 찾기

Q. "mid 계산 시 주의할 점은?"
- A. (left + right) / 2는 오버플로우 가능. left + (right - left) / 2 권장

Q. "범위 설정을 maxLength로 한 이유는?"
- A. 기존 랜선보다 긴 길이는 물리적으로 불가능하므로
# 📂 [Algo] 백준 2110 - 공유기 설치

> 날짜: 2026-01-27 | 난이도: Gold 4 | 알고리즘: 이분 탐색(매개변수 탐색)

## 1. 문제 분석 💡
**목표**: C개 공유기를 설치할 때, 가장 인접한 두 공유기 사이의 **최대 거리** 구하기

**핵심 아이디어**:
- "최소 거리의 최댓값" 찾기 → 이분 탐색
- 판정 함수: 거리 D로 C개 설치 가능한가?
- 가능하면 거리 늘려보기, 불가능하면 거리 줄이기

**시간 복잡도**: O(N log N + N log L)
- 정렬: O(N log N)
- 이분 탐색: O(log L) × 배열 순회 O(N) = O(N log L)
- L: 최대 거리 (최대 10억)

## 2. 핵심 로직 ⭐
**이분 탐색 범위 설정**:
- left = 1 (최소 거리)
- right = houses[N-1] - houses[0] (양 끝 거리)
  → ⚠️ 인접 집 최대 거리가 아님!

**판정 함수 (그리디)**:
1. 첫 집에 무조건 설치
2. 다음 집: 이전 공유기와 거리 >= mid → 설치
3. 설치 개수 >= C → 가능

**이분 탐색**:
- 가능하면 → answer 갱신 + 거리 늘리기 (left = mid + 1)
- 불가능하면 → 거리 줄이기 (right = mid - 1)

## 3. 그리디 정당성 증명 🎓
**주장**: 최소 거리를 넘으면 즉시 설치하는 게 최적이다.

**증명**:
- G = 그리디 해 (왼쪽부터 촘촘히)
- O = 임의의 최적해

1. 그리디는 최소 거리만 넘으면 최대한 왼쪽에 설치
2. 최적해도 최소 거리는 넘어야 설치 가능
3. 그리디 해를 최적해로 대체해도 남은 거리 ≥ 유지
4. 즉, 그리디가 설치 가능한 경우 ≥ 최적해
5. ∴ 그리디 = 최적해 (모순 없음)

## 4. 트러블슈팅 & 배운 점 🚩
**함정 1**: 이분 탐색 범위
- ❌ right = 인접 집 최대 거리 → 논리 오류
- ✅ right = 양 끝 거리 (houses[N-1] - houses[0])
- 이유: 정답 범위는 [1, 전체 거리]

**함정 2**: 정렬 필수
- 좌표 정렬 안 하면 거리 계산 불가능
- Arrays.sort(houses) 반드시 선행

**함정 3**: mid 오버플로우
- ❌ mid = (left + right) / 2
- ✅ mid = left + (right - left) / 2

**최적화**: 설치 개수 >= C이면 즉시 return

## 5. 면접 대비 🎤
Q1. "왜 정렬이 필요한가요?"
- A. 거리 계산을 위해 좌표가 순서대로 정렬되어야 함

Q2. "왜 첫 집에 무조건 설치하나요?"
- A. 그리디 전략. 왼쪽부터 채워야 남은 공간 최대 활용 가능

Q3. "그리디가 왜 맞나요?"
- A. 왼쪽부터 촘촘히 채우는 게 남은 기회를 최대화함 (증명 참고)

Q4. "시간 복잡도가 왜 O(N log L)인가요?"
- A. 이분 탐색 O(log L) × 배열 순회 O(N)
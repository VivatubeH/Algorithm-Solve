# 📂 [Algorithm] 백준 2840 - 행운의 바퀴

> **관련 링크**: https://www.acmicpc.net/problem/2840
> **난이도**: 실버 4
> **학습 날짜**: 2026-01-18

---

## 1. 문제 해석 🔍
* **목표**: 상덕이가 바퀴에 적어놓은 알파벳(초기 바퀴의 구성) 알아내기.
* **입력 값**: 바퀴의 칸은 최대 25칸, 바퀴 돌리는 횟수는 최대 100회
* **제약 사항**: 시간 제한 1초, 메모리 제한 128MB
* **핵심 포인트**: 바퀴를 돌리는 횟수에 맞게, 바퀴 모양 만들어내기 ( 유추 )

## 2. 해결 전략 (아이디어) 💡
* **사용 알고리즘**: 시뮬레이션 ( 브루트포스 )
* **풀이 프로세스**:
    1. 바퀴 판을 N크기로 생성하고 체크를 위해 ?를 default로 초기화한다.
    2. K줄에 걸쳐 입력을 받으면서 실제 바퀴에 동작을 기록한다. 단, 기록 시 모순이 나오면 종료한다.
    3. K줄에 입력이 끝난 뒤에, 모순이면 !를 출력하고 아니면 판을 시계방향으로 찍어낸다.
* **핵심 아이디어**: 처음에 특정이 불가하므로, 시뮬레이션으로 모양을 그려내고 모순 찾기.

## 3. 복잡도 분석 ⏳
* **시간 복잡도**: O(S x K) = K줄에 걸쳐 바퀴를 S칸씩 돌려가며 시뮬레이션 ( 순회 )
* **공간 복잡도**: 바퀴의 칸수 N을 char 배열, 시뮬레이션 시 사용할 변수들

## 4. 핵심 코드 리뷰 ⭐
* **paint**: 나머지 연산을 통해 인덱스 조작하면서 판화를 그려내는 메서드
* **인덱스 계산**: 음수 인덱스 보정을 위해 배열 크기를 더해준다. (예: 25칸 배열에서 -1칸은 25 + (-1)인 24칸 이동과 같다.)

## 5. 트러블슈팅 / 느낀 점 🚩
* **실수했던 점**: 동일 알파벳이 여러 번 들어가면 안된다는 점을 놓쳐서 최초에 틀렸다.
* **개선 방향**: 이동은 시계방향, 실제 배열에서는 시계 반대방향, 출력은 시계방향이라 방향 설정을 잘 잡고 들어와야할듯
* **배운 점**: 인덱스 연산으로 시간 복잡도 줄이기, 음수 인덱스 보정하기
# 📂 [Algo] 백준 2230 - 수 고르기

> 날짜: 2026-01-28 | 난이도: Gold 5

### 시간 복잡도
- 중첩 for문으로 두 수 선택 차이 구하기 : O(N^2) - 시간 초과
- 정렬 O(N logN) + 투 포인터 O(N) : 시간 내에 가능

### 알고리즘
- **정렬 + 투 포인터**

### 핵심 발상
- 어떻게 시간 복잡도를 줄일까? 
- 투 포인터 적용이 가능할까? 그럼 단조성이 있어야 함.
- 정렬이 되어 있다는 전제하에, right가 커지면 차이가 커지고, left가 커지면 차이가 작아짐.
- 단조성이 확보되기 때문에 투 포인터 적용이 가능함.

### 코드 로직
1. 정수 크기 size, 목표가 될 target을 한 줄에 공백을 두고 입력받는다.
2. size 크기만큼의 int 배열 array를 생성한다.
3. size개의 수를 int 배열 array에 담는다.
4. 단조성을 위해 array를 오름차순 정렬한다.
5. 투포인터 탐색을 개시한다.
- 바깥 for문 : left를 늘린다. ( 0부터 N보다 작은 동안 )
- 안쪽 while문 : right < size && `array[right] - array[left] < target`인 동안 반복한다.
- while문이 끝났을 때 right 체크 필수, target보다 차이가 크거나 같으면서 min보다 작을 때 갱신한다.
- target이 0이어도, while문이 거짓이 되고 right - left = 0이므로 min이 0으로 갱신되게 한다.

6. min을 출력한다.

### 핵심 수식
- `diff = A[right] - A[left]` // right가 커지면 diff가 커지고, left가 커지면 diff가 작아짐.

### 주의점
- 같은 수를 고를 수가 있기 때문에, M == 0이라면 똑같은 두 원소를 고르면 무조건 가능.
- 이 문제 같은 경우 합이 아닌 두 수의 비교이기 때문에 음수여도 가능함. (단조성 보장)
- num1 - num2는 num1이 클수록, num2가 작을수록 차이가 크기 때문
- 두 수의 차가 int 범위를 벗어날 수는 없음.

### 트러블슈팅 & 배운점
- 인덱스 범위 초과에 대해 코드 작동 로직을 그려보고, 방어적인 코드를 짰다.
- min 초기값을 Integer.MAX_VALUE로 한 이유는 두 수의 최대 차이가 20억이기 때문이다.
# 📂 [Algo] 백준 1806 - 부분합

> 날짜: 2026-01-28 | 난이도: Gold 4

### 1. 핵심 아이디어 💡
* **알고리즘**: 투 포인터(Two Pointer)
* **핵심 발상**: 
* - 배열의 i, j를 반복하면서 부분합 구하기 : O(N^3) 시간 초과
* - **투 포인터** : i, j를 한 방향으로 움직이면서 합을 조정한다. O(N)

### 2. 코드 리뷰 & 로직 ⭐
* **주의점**: 단조성이 있기 때문에 가능. ( right가 이동시 합이 커지고, left가 이동시 합이 작아짐 )
* **코드 로직** 
* 1. N개의 int 배열을 생성한다. (int 범위로 가능 10만 x 1만 = 10억 )
* 2. int 배열의 각 요소를 입력받는다.
* 3. left = 0, right = 0에서 출발해서 투포인터 이동을 시작한다.
* 4. for문을 통해 left는 고정시킨 채 가능한 right를 늘려본다.
* 5. while문을 통해 right가 배열 범위 내이면서, sum이 target보다 작은 동안은 증가시킨다.
* 6. sum이 S보다 크거나 같으면 이 때의 길이 len(right - left)을 min과 비교해서 작으면 기록한다.
* 7. 이후 left를 합에서 빼준다. (이후 left가 이동하기 때문)
* 8. 불가능하면 0을 출력해야 하니, 갱신이 안된 초깃값이면 0을 출력하도록 짠다. ( 초깃값이 0이면 갱신 불가 )

#### 3. 피드백
- 생각해보니, 이 문제에서 min 초기값을 `N + 1`로 하는게 더 명확하다. ( 배열 길이보다 더 길 순 없음 )

##### `sum >= S` 조건을 while문 외부에서 검사하는 이유 
1. while문은 sum < target인 동안만 수행됨.
2. 종료 직후는 sum >= target이 된 최초 시점 or 더 이상 더 할 원소가 없음
3. 이 때, if (sum >= target)으로 성공 여부를 확인하면 left에서 얻을 수 있는 최단 구간이 됨.
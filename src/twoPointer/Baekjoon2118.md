# 📂 [Algo] 백준 2118 - 두 개의 탑
## 추후 다시 볼 것. 

> 날짜: 2026-01-28 | 난이도: Gold 5

### 시간 복잡도
- N개 중 2개의 탑 선택해서 거리 재기 : O(N^2) - 시간 초과
- 누적합 + 투포인터 : O(N) + O(N) - 시간내에 가능.
- 한 쪽 방향으로 보면 left, right 중 right가 커지면 멀어지고, left가 커지면 가까워지는 단조성이 존재함. 

### 알고리즘
- 투포인터 알고리즘 + 누적합

### 핵심 발상
- 시계 방향 거리 + 시계 방향 거리 = 전체 거리의 합
- 한 방향으로 가는 거리는 단조성을 띄므로 누적합 사용 가능.
- a에서 b까지의 거리를 토대로 b에서 a까지의 거리도 알 수 있다.
- b에서 a까지의 거리 = (전체 거리) - (a에서 b까지의 거리)
- a에서 b까지의 거리는 누적합을 이용해서 O(1)에 구간합으로 조회 가능

### 코드 로직
1. 지점의 개수 N을 입력받는다.
2. N + 1 크기의 거리를 저장할 배열 array을 생성한다. (1-based Indexing)
3. 누적합을 저장할 N 크기의 배열 prefixSum[N + 1]을 생성한다.
4. 거리를 입력받으면서 array와 prefixSum을 갱신한다.
5. left를 1~N지점으로 이동한다.
6. 이 때, right 역시 1~N 지점으로 이동하는데, left와 right 사이 거리가 절반보다 작을 때만 이동한다.
7. 이동 중에 거리가 최대 거리가 되면 갱신한다. ( 나왔을 때, 최대 거리가 아닐 수 있음. )
7. while 문이 종료되었다는 건, 절반보다 크거나 right가 N 지점을 통과했다는 것이다. ( 이 때도 최대 거리인지 체크가 필요하다. )

### 인덱스 
- 거리는 지점과 지점 사이에 존재한다. 
- 예) `N = 5`일 때,
- `array[1]` : 1번 지점 -> 2번 지점 거리
- `array[2]` : 2번 지점 -> 3번 지점 거리
- `array[3]` : 3번 지점 -> 4번 지점 거리
- `array[4]` : 4번 지점 -> 5번 지점 거리
- `array[5]` : 5번 지점 -> 1번 지점 거리

#### 누적합(PrefixSum) 정의 및 차이
- `PrefixSum[i]`: **"1번 지점에서 i번째 지점까지 시계방향으로 떨어진 거리"**
- `prefixSum[1] = 0` // 그래서 prefixSum[1] = 0이 되어야 한다.
- `prefixSum[2] = array[1]` // (1번에서 2번까지 거리)
- `prefixSum[3] = array[1] + array[2]` // (1번에서 3번까지의 거리)
- `prefixSum[N] = array[N - 1]까지의 합`
- `totalSum = prefixSum[N] + array[N]` // 다시 1번으로 돌아오는 전체 둘레

#### 지점 a부터 지점 b까지의 거리 ( a < b )
1. **시계 방향 거리** : **`prefixSum[b] - prefixSum[a]`**
2. **반시계 방향 거리** : `totalSum - (시계 반대 방향 거리)`

### 핵심 수식
- `dist1 (시계방향)` = `S[right] - S[left]`
- `dist2 (반시계방향)` = `totalDistance - dist1`
- `currentMin` = `Math.min(dist1, dist2)` // 두 지점 사이의 실제 거리

### 주의점
- 찾으려 하는 것 : min(시계, 반시계)의 최댓값
- **핵심** : **시계 방향(dist)이 절반에 가까워질수록 실제 거리(min)이 커진다.**
- 즉, 두 탑을 **원형의 반대편**에 서있게 할 때가 최대 거리가 된다.
- left가 1~N인 이유 : 1번부터 N번 탑은 모두 기준점이 되어봐야 한다.
- right가 1~N인 이유 : right는 한 바퀴를 채우기 전까지만 움직인다. ( right가 left를 한바퀴 돌아 추월하면, left, right가 바뀌었을 때 계산했던 거리와 동일하다. )

### 트러블슈팅 & 배운점
- 인덱스를 좌표로 생각하는 것이 필요하다. ( 1번 지점의 좌표는 0 )
- 투포인터가 모든 좌표를 훑는 건 아니고, 단조성으로 인해 가망 없는 조합은 버릴 수 있다.
- "엿보기(Look-ahead) 전략": right를 실제로 이동시키기 전에 다음 칸(right + 1)의 거리를 미리 계산해보고,
절반(total / 2)을 넘지 않을 때만 실제로 이동시킨다. 절반을 넘는다면 이동은 하지 않되, 그 지점의 지름길 값만 max 갱신에 사용하고 break 한다. (이래야 right가 뒤로 돌아오는 일이 없다.)
# 📂 [Algo] 백준 17609  - 회문

> 날짜: 2026-01-29 | 난이도: Gold 5

### 시간 복잡도
- O(T × N) (N: 문자열 최대 길이 100,000)
    - 각 문자열마다 최악의 경우 3번 순회 (원본 1번 + 삭제 케이스 2번)
    - 실제로는 O(3N) ≈ O(N)이지만, T개 처리하므로 총 O(T × N)

### 알고리즘
-  투 포인터 (Two Pointer)

### 핵심 발상
- 회문 판단, 유사 회문 판단, 그 외의 기준을 명확히 세워야 함.
- 회문 : 양방향에서 조여 들어올 때, 두 포인터가 만날 때까지 두 문자가 같으면 회문 ( 동일 인덱스면 당연히 같음 )
- 유사 회문 : 회문이 아닌데, 한 문자를 삭제하면 회문이 됨.
- 즉, 문자에 대해서 투 포인터로 회문인지 체크하고
- 회문이면 0을 출력하고 회문이 아니면 한 문자를 삭제한 게 회문인지 재차 체크한다.
- 이 때도 회문이 아니면 2를 출력하고 이 때 회문이면 1을 출력하면 된다.
- 이 때, 회문이 아닐때 서로 다른 left, right를 기준으로 삭제해야 하기 때문에 left, right 관리가 중요

### 코드 로직
- T개의 문자열을 입력받는다.
- 문자열에 대해서 left = 0, right = 문자열 길이 - 1로 양방향에서 좁혀오는 투포인터 탐색을 한다.
- left < right인 동안 양쪽 포인터가 가리키는 문자가 같으면 회문이 된다.
- 단, 중간에 left와 right가 다른 경우에는 left = left + 1, right = right - 1이 회문인지 체크한다.
- 이 때, 둘 중 하나가 회문이 된다 == 한 문자를 삭제한 게 회문이 된다.
- 유사회문임을 판별할 수 있다. 반면 둘 다 회문이 아니면 유사회문도 아니게 된다.

### 핵심 수식
- 체크로직 : `word.charAt(left) `과 `word.charAt(right)`가 같은가? ( 회문이면 같아야 함 )
- **유사회문 체크**: 불일치 시점에서
    - `isPalindrome(word, left+1, right)` (왼쪽 문자 삭제)
    - `isPalindrome(word, left, right-1)` (오른쪽 문자 삭제)
    - 둘 중 하나라도 true면 유사회문
  
### 주의점
- 메서드를 계속 호출하기 않도록, 메서드를 분리하는 게 필요하다.
- 회문이 아닐때 left, right를 기준으로 좁혀나가야 한다. ( 이미 검사한 구간 중복 검사는 X )

### 트러블슈팅 & 배운점
- **문제**: 처음에 `check()` 하나로 재귀 구현 → 시간 초과
- **원인**: 불일치 시점마다 재귀 호출이 중첩되어 O(N²) 이상 소요
- **해결**: `isPalindrome()` 별도 분리 + 반복문 사용으로 O(N) 유지
- **교훈**: 투 포인터는 재귀보다 반복문이 효율적 (스택 오버헤드 없음)
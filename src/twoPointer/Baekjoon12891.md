# 📂 [Algo] 백준 12891 - DNA 비밀번호

> 날짜: 2026-01-28 | 난이도: Silver 2

### 시간 복잡도
- 부분문자열 길이만큼 매번 검사 : O(S * P) - 시간 초과
- 투포인터로 이동하면서 알파벳 개수 더하거나 빼기 : O(S) // 특정 위치를 더하거나 빼는건 1번만 이루어진다.

### 알고리즘
- 투 포인터 ( 슬라이딩 윈도우 ) : 부분 문자열 길이 일정

### 핵심 발상
- 시간 복잡도를 줄이려면 어떻게 해야할까?
- 문자열이 중요한 게 아닌, 개수 조건만 만족하면 됨.
- 투 포인터로 문자열 개수를 체크만 하자.
- 단, 슬라이딩 윈도우니 left를 이동할 땐 빼고, right를 이동할 땐 더한다.

### 코드 로직
1. 문자열 길이 dnaLength와 부분 문자열의 길이 partLength가 주어진다.
2. 문자열 dnaWord를 입력받는다.
3. i = 0부터 i < partLength인 동안 문자별 개수를 미리 기록한다.
4. 이 개수가 만족하는 비밀번호 개수로 센다.
5. 최초 left = 0, right = partLength - 1로 둔다.
6. `right + 1 < dnaLength`이면 다음칸으로 이동할 수 있으므로 이 때만
7. left와 right를 우로 이동하고, left에 해당하는 알파벳은 빼고, right에 해당하는 알파벳은 더한다.
8. 이후에도 알파벳의 최소 개수를 만족하면 count를 세준다.

### 핵심 수식
- 우측으로 이동 시, 추가되는 알파벳은 더하고, 빠지는 알파벳은 뺀다.

### 주의점
- **배열 인덱스 범위** : 슬라이딩 윈도우 이동 시, 인덱스 조작 시 순서가 꼬이지 않도록 주의하기.

### 트러블슈팅 & 배운점
- **기록할 점** : 부분 문자열 길이를 매번 다시 세지 않고, 새로 들어오는 것과 나가는 것만 처리해도 상태 유지 가능.
- **깨달은 점** : 구간 합이나 개수를 구할 때, 구간 길이가 고정되어 있으면 슬라이딩 윈도우를 쓴다.
- **포인터 단순화** : left, right 두개 변수가 아닌 left가 정해지면 right도 결정되므로 하나로 가도 된다.